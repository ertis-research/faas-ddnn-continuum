---
toc: true
toc-own-page: true
author: [Altair Bueno]
title: FaaS on a controlled environment
---

<!--
recursos:
  - https://dl.acm.org/doi/10.1145/3565382.3565878
notas:
  - Debería separar fission, openfaas etc por secciones? CLI, instalación, UX, rendimiento....
    - CLI
    - Instalación
    - UX
    - Rendimiento
    - Triggers
    - Features diferenciadoras
  - Deberían ser minimo 6 páginas del template

- Introduction
- OpenFaaS
  - Installation
  - Developing functions
  - Templates and the store
  - Function lifecycle
- Fission
  - Installation
  - Developing functions
  - Function executors, triggers and specs
  - Function lifecycle
- OpenWhisk
  - Installation
  - Developing functions
- Comparison between these platforms
- Conclusions and future work
-->

# Introduction

In the recent years, FaaS (Functions as a Service) has proven to be a valid
alternative approach to traditional cloud computing. It's stateless nature
allows them to scale horizontally on-demand by reacting to events, which
translates to multiple instances running under heavy load, or no instances at
all. This automatic scaling is cost-effective, and empowers developers to focus
on solving problems instead of worrying about the underlying infrastructure.

Several Internet of Things (IoT) applications require efficient and flexible
cloud computing solutions that can react to handle the large and unpredictable
flows of data generated by the connected devices

While major cloud providers offer proprietary FaaS platforms, these are often
vendor-specific and lack flexibility. This document provides a general overview
of several open-source FaaS platforms and their potential applications in the
context of IoT

# OpenFaaS [^1]

It's a Kubernetes-native serverless platform featured on the Cloud Native
Landscape. It's licensed under the MIT license and it currently holds the title
for most stars of any hosted serverless platform in GitHub, with over 22k
stars[^2]. OpenFaaS also offers a paid version, OpenFaaS Pro, which builds upon
the open source project to deliver some additional features and commercial
support

[^1]: https://www.openfaas.com/
[^2]: https://github.com/openfaas/faas

## Installation

The platform can be deployed to any certified Kubernetes distribution or a
single host. For our purposes, we decided to deploy the full OpenFaaS platform
on a Kubernetes cluster. The platform can be installed using Helm or Arkade
charts, allowing for customization on the installation.

The installation guide[^3] also provides instructions on how to install
`faas-cli`, a Command Line Interface (CLI) available on Linux, Windows and
macOS. It's a single executable that provides developers with a friendly
interface to develop serverless functions, as well as operators to manage the
OpenFaaS Gateway

[^3]: https://docs.openfaas.com/deployment/

## Developing functions

OpenFaaS documentation includes multiple tutorials and learning resources that
ease the learning curve. For example, the "First Python Function"[^4] tutorial
is straightforward and covers step by step everything required to deploy a
Python function with PyPI dependencies from scratch. The development workflow
usually involves these steps:

1. **Pull a template from the store**. `faas-cli` has this concept called
   _templates_, which makes posible to scaffold a whole OpenFaaS function with
   one command.
2. **Modify the OpenFaaS stack file**: Each function comes with a YAML
   description file used by `faas-cli` to deploy de function. The developer can
   enable certain configuration options by modifying this file. Commonly used
   options include environment variables, secrets and build options
3. **Modifying the source code**
4. **Deploy the function to OpenFaaS Gateway**: Use the `faas-cli up` command to
   deploy the function. This step builds a Docker image that is later pushed to
   a Docker Registry, and used by OpenFaaS to instantiate functions

What makes OpenFaaS so effortless to get started is the abstraction of the
underlying technologies. In fact, cognizance about OpenFaaS itself isn't
mandatory. A developer can create a function and update both the source code and
the stack file at any point in the future, meaning the only required steps for
deploying a function are pulling the template and deploying the function. Of
course, you will eventually need to acquire this knowledge in order to create
any meaningful function (for example, providing environment variables or secrets
to your functions), but is not a cost you pay upfront

[^4]: https://docs.openfaas.com/tutorials/first-python-function/

## Unique features: Templates and the store

The `faas-cli` includes a template engine built-in that can generate a new
OpenFaaS project in a given programming language[^5]. There are multiple
programming languages officially supported, including popular ones such as
Python, JavaScript, Ruby or Java. These templates usually come with multiple
flavors that include extra dependencies or switch the base docker image. There
is also a vibrant ecosystem of community maintained templates, which enables
developers to create functions on other languages not officially supported by
the OpenFaaS team. These templates are shared using the OpenFaaS store, which
serves as template manager

[^5]: https://docs.openfaas.com/cli/templates/#templates

# Fission

Another Kubernetes-native serverless platform, also featured on the Cloud Native
Landscape. It's licensed under the Apache 2.0 license and has 7.4k stars on
GitHub. It offers an interesting concept called _environments_, which are a set
of running containers with a small dynamic loader ready to launch functions.
This allows for functions to start immediately, reducing the latencies for cold
starts

## Installation

Fission can be installed using Helm charts or Kubernetes objects, although Helm
allows more features to be enabled. This is important, as the base Fission
installation only includes the core components required for developing and
testing functions. This results on a smaller control plane, but requires the
operator to enable each feature individually. For example, the Kafka event
trigger requires KEDA installed on the cluster, as well as enabling the KEDA
integration on Fission.

The installation guide also provides instructions on how to install `fission`, a
CLI available on Linux, Windows and macOS. It's a single executable that allows
users to operate Fission on the cluster.

## Developing functions

Fission's documentation is complete and describes all the main features of the
platform. The developer team has curated a great set of examples for all of the
languages they support, which makes developing a new function easy. The
developer experience usually involves the following steps:

1. **Choosing the right environment**: Each function requires an environment to
   run. You can create as many environments as you need with different options,
   but a function can only run on one environment
2. **Scaffolding the project**: Fission's CLI does not provide a way to scaffold
   a new project automatically. Each environment comes with it's own builder,
   which is used to compile and install dependencies. The developer is
   responsible of reading the instructions and creating a project structure that
   matches the builder's requirements
3. **Modifying the source code**
4. **Deploying the environment and function**: The `fission` CLI is used to
   package the source code and send it to the selected environment builder.
   Fission doesn't create triggers for functions by default, which means that
   the function will be only available using the `fission fn test` command.

To automate function deployment, Fission offers _specs_ which are Kubernetes
Custom Resources Definition files (CRD) that the CLI understands. One advantage
of this approach over running `fission` commands directly is that environments
can be extended using Kubernetes Pod specs. This provides functions with access
to volumes, environment variables and sidecar/init containers.

Fission's unique approach to serverless has a stepper learning curve: Developers
must learn the basics of environments before creating functions, as well as
reading the instructions of the selected environment on how to scaffold the
project. On the flip side, Fission's specs provide developers with a familiar
interface which can be a big advantage for developers used to Kubernetes CRDs

## Unique features: Environments

As previously stated, Fission's environments are a key feature of the platform.
They are the language-specific parts of Fission. They are made up of a container
with an HTTP server, and usually a dynamic loader (_fetcher_) that can load a
function. Some environments also contain builder containers, which take care of
compilation and gathering dependencies. [^6]

Environments can be configured with two strategies: **PoolManager** and
**NewDeploy**:

- **PoolManager**: Fission keeps a running set of "warm" pods from the selected
  environment. When a request arrives, the fetcher downloads the function and
  injects it into the environment. This pods will be used for subsequent
  requests, and will be cleaned after a certain idle period. This strategy is
  great for functions that are short living and require short cold start
  times[^7]
- **NewDeploy**: Creates a Kubernetes Deployment with a service and a
  HorizontalPodAutoscaler (HPA) for function executions. This enables
  autoscaling of function pods and load balancing the requests between pods.
  When a function experiences a traffic spike, the service helps to distribute
  the requests to pods belonging to the function. The HPA scales the replicas of
  the deployment based on the conditions set by the user. If there are no
  requests for a certain idle time, the idle pods are cleaned up. This strategy
  though increases the cold time of a function it allows functions to serve
  massive traffic[^8]

[^6]: https://fission.io/docs/concepts/#environments
[^7]: https://fission.io/docs/architecture/executor/#poolmanager
[^8]: https://fission.io/docs/architecture/executor/#new-deployment

# OpenWhisk

A serverless platform from the Apache foundation, licensed under the Apache 2.0
license. It has the least amount of stars on GitHub of all three platforms, with
5.9k, but it offers some interesting features not available on neither Fission
or OpenFaaS. The project is the serverless platform of choice for IBM, who uses
OpenWhisk as machinery behind IBM Cloud Functions[^9]

[^9]: https://www.ibm.com/es-es/cloud/functions

## Installation

OpenWhisk offers many different deployment options: The platform can be
installed on Kubernetes, Docker (with Docker Compose), Ansible and Vagrant. We
choose to install OpenWhisk on Kubernetes using the official Helm chart. This is
one key feature of OpenWhisk, as the platform keeps the same functionality
despite the installation method.

The installation wasn't easy. Because OpenWhisk aims to support multiple
deployment options, it becomes difficult to track down deployment errors. It's a
never ending cycle of reading through logs from the different pods and guessing
what could be wrong. One of the multiple issues we had was related to a
misconfiguration on OpenWhisk, which made pods unable to discover each other.
Thankfully, some of this errors were documented on a troubleshooting file inside
the docs repository.[^10]

The installation guide wasn't great either. Although it provided instructions
for different Kubernetes flavors such as Kind, OpenShift and upstream, these
documents weren't complete as the some values for the Helm chart were missing.

The installation guide also provides instructions on how to install `wsk`, which
is a CLI tool available on Linux, Windows and macOS used to manage functions.
`wsk` is available to download from the GitHub releases page as a single binary.
OpenWhisk also offers a companion CLI, `wskdeploy`, which allows deployments
using YAML description files

[^10]:
    https://github.com/apache/openwhisk-deploy-kube/blob/master/docs/troubleshooting.md

## Developing functions

OpenWhisk documentation includes minimal examples on how to deploy basic
functions on all of their supported languages, including popular options such as
JavaScript, Go, Python and Java. These functions are composed of one single
source file and are directly submitted to the control plane for execution. For
more complex functions, such as those using external dependencies, they provide
links to community made blog posts. The developer workflow usually involves the
following steps:

1. **Scaffolding the project**: OpenWhisk does not enforce any particular way of
   Creating the source files required for the function
2. **Modifying the source code**
3. **Deploying the function**: The developer is required to manually zip the
   source files and upload the archive to using the `wsk` CLI.

<!--

We tried multiple times to develop our simple example `redis-glue` for
OpenWhisk, but we weren't able to do so


- Python 3.6 is not compatible with Redis 4.4.0
- Function invocation kept yielding the same error

```
{
    "error": "The action failed to generate or locate a binary. See logs for details."
}
```
- We where unable to locate the logs. The pod were instantly destroyed and the docs didn't provide information on where to find said logs
- Searching throught the control pane logs didn't yield results. Error messages weren't usefull at all

```
[2023-01-18T10:27:30.948Z] [INFO] [#tid_sid_dbBatcher] [CouchDbRestStore] 'test_activations' saving 1 documents [marker:database_saveDocumentBulk_start:81531062]
[2023-01-18T10:27:30.948Z] [ERROR] [#tid_sid_unknown] [ContainerProxy] Failed during init of cold container Some(ContainerId(wskowdev-invoker-00-8-guest-redisglue)), queued activations will be aborted.
[2023-01-18T10:27:30.949Z] [INFO] [#tid_r74NrE3H5G0rHLht3CX6TNVUyI8Dp4Cc] [MessagingActiveAck] posted completion of activation 762dfbfc722c425badfbfc722c325b02
[2023-01-18T10:27:30.949Z] [INFO] [#tid_sid_invokerNanny] [KubernetesClient] Deleting pod wskowdev-invoker-00-8-guest-redisglue [marker:invoker_kubeapi.delete_start:81531063]
[2023-01-18T10:27:30.968Z] [INFO] [#tid_sid_dbBatcher] [CouchDbRestStore]  [marker:database_saveDocumentBulk_finish:81531081:19]
```

-->
